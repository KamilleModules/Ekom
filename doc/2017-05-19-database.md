Database
==================
2017-05-19




This is a major update of the ekom database (database.md).

You might get a better understanding of how this database works by reading the database.md document.



Lang
=========
- label
- iso_code: a 639-3 iso code http://www-01.sil.org/iso639-3/codes.asp





Currency
=========
- iso_code: iso code 4217
- symbol: the symbol representing the currency (for instance $)



Timezone
-----------
- name:




Shop
=========

This represents a virtual store.

It holds the configuration of your e-commerce.

Usually, on the front office, a shop is identified by a host, but not always.

A shop is not directly bound to products.

Instead, a shop contains stores, a store being the container for products.
 
 
 
- label: a label to identify the store in the backoffice (not displayed in front)
- host: null|string, the host used to identify the front office shop (if null, other heuristics are used to select the front office shop).
- lang_id: the default lang used for this shop: is the default language on the front, and is also the back-office language for this shop
- currency_id: the currency used by default for this shop (default currency of the front, and currency of the back-office)
- timezone_id: the time zone used by this shop




Shop_configuration
====================

This is an extension of the shop.
Basically, providing a dynamic structure for modules/plugins to hook in.


- key
- value




Store
=========

This represents a physical store.

It's a container for products, even virtual products (don't let the word physical fool you).

- label



Shop has store
=========



Product_type
=============

The product type.

It is mainly used as a group for calculating shipping costs,
but it could be used for any other operation.

For instance: a downloadable product will have no shipping cost,
whereas a non downloadable product will have shipping costs.


Product types are owned by shops.

- label



Shop has product_type
=========



Product
===============

The product represents a unique product, that is a product with a unique set of attributes.

The product might be physical or downloadable.
A weight of 0 means downloadable, or at least it represents the intent of not charging shipping costs for this product.


The product might have no attributes at all.


- reference: uq, the unique reference                
- label: the label for this product
- weight: the weight for the product, or 0 if the product has no weight (like a downloadable product for instance)



Store has product
==================
- quantity: -1|int, if -1, means infinite storage (this might be useful for virtual products).
            Otherwise, it's the number of physical products remaining.





Reference has attributes
===========================

- value: the value associated with the reference-attribute combination.






Attributes
=============

Attribute names. 
Attributes will be attached to references.





Tax
=========

Tax represents any tax that you want to apply to a product.
Tax is a complex topic, as a tax can be applied depending on various parameters:

- the user type (b2b, b2c)
- the seller location
- the shipping location
- the product type
- ...

But in the end, the tax can be modelized as a percentage added to the price of a product.

To make the model flexible, we use conditions to determine whether or not a tax applies to a given product.
 
If a tax is not bound to any conditions, then it applies.
If there is at least one condition, then all the conditions must match in order for the tax to apply. 


Note: the product must be bound to a tax to allow the tax computation in the first place.
 

- amount: the amount of the tax in percent





Tax_lang
=============
- label: 



Condition
==============

A general condition table.
This table can be used in various contexts (checking if a tax applies for instance).

- type: custom string to specify/group conditions by affinity
- combinator: none|or|and: default=none
- negation: tinyint(0|1), whether to prefix the rest of the condition with the negation operator (!)
- start_group: tinyint(0|1), whether or not to start the rest of the condition with an opening parenthesis
- end_group: tinyint(0|1), whether or not to end the condition with a closing parenthesis
- left_operand:
- operator:
- right_operand:
- right_operand2:
- ...: might be more in the future



Tax_has_condition
=========



Tax_has_product
=========
A more explicit name for that table would perhaps have been: tax_is_assigned_to_product,
or product_is_assigned_to_tax.

A connection between a product and a tax means that the product CAN be affected by the tax.

However, the tax will be effectively applied based on the conditions bound to the tax.


This bindure is decided at the shop level.


- shop_id









