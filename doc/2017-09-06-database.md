Database
==================
2017-09-06




This is a minor revision of 2017-05-30-database.md.

The main change is moving the ek_product_type table.

The product type table depends on the shop, and therefore couldn't be linked directly
to the ek_product table, since ek_product is an abstract, shop independent table.

So, ek_product_type is now bound at the shop level, to the ek_shop_has_product table.







The most important things to important are the following:




Product vs product card
--------------------------


We sell products, however, we present them as product cards on the website.

That is, you first "seduce" the customer with a product card,
but then, when it's time to pay, only the products are considered.

- a product is unique, and must belong to a product_card, which is a container to hold/present products.
- the product must belong to one and only one product card     
- we always buy product, not product cards. A product card is just a way to display/manage products     
- a product card can be seen as a canonical reference for the different variations of a given product     
- all the products in a product card have the same attributes, and differ only by a variation of attribute values
- it's the product that holds the price, not the product card 




Translations 
--------------------------
Translation is a recurrent topic in any web application.
There are at least two ways to handle translations:

- using the application's translation system
- using the database

Using the application's translation system is arguably a more flexible solution
than using a database, since an application's translation system often provides
the concept of context, which is not present in our ekom database system.


So, note that when possible we would prefer to delegate the translations
to the application.

Now, there are two types of data stored in the database:

- static
- dynamic


Static data is predictable data, for instance: the name of the languages, or the names
of the currencies, etc...

Dynamic data on the other hand is rather unpredictable. 
It's data typed by the user: for instance the products labels and descriptions,
the product attribute names and values, ...



Our philosophy with the ekom database is to store only dynamic data translations in the database,
and let the application handle translations for static english data.



No images
-----------
Notice that there is no image column.
That's because in ekom, we have a philosophy on how to handle images: we use conventions for naming images, and 
so the image path is predictable, and thus doesn't need to be stored in the database.

One of the drawback is that we cannot search for an image: we loose the search facility provided
by the database (but it doesn't matter, right?, or if it does, you can always implement a search system).

Images are needed for products, categories, manufacturers, payment providers maybe, ...

The point is that it's always associated with something, and we call this something a type.

Here is why we do it this way.

First, we have a problem with the image insertion.
Imagine we had a table named "product", containing an image column.

The problem is: how do you know the path of the image?
Imagine the user uses a form via your gui.
 
The product is not created yet, and yet the user can upload an image.
Ok, but what's the path of the image? 

What we probably want is to create an image based on the id of the product, or the reference,
but since the product is not registered, you don't have such information when the user uploads the image.

And if you decide that: no problem, you will add a transformer AFTERWARDS, then the user might complain
because you change the name they give to the image, so that's a source of problem right there.

As a side note, don't bother having seo image path, just give a semantically correct filename to your image,
because apparently you won't improve your seo by tuning up every subdirectory leading to your image.

https://webmasters.stackexchange.com/questions/36434/what-should-filenames-and-urls-of-images-contain-for-seo-benefit

But back to the problem, it's a chicken-egg problem that we have.

And we have multiple workarounds available for that.
 
The one we chose is to not put the image path in the database.

Rather, we use a convention that makes image paths predictable; the convention is the following:

Every image is put in a directory representing the item to which the image is attached to.

For instance, if the image is attached to a product with id:650, then the type is product,
and all images for this product #650 are located inside the base directory:

```txt
/my/app/www/$relImgBaseDir/6/5/0/

With $relImgBaseDir = img/products    // but that can be changed using the module configuration  
```

Then from that base directory, we have some other subdirectories representing the characteristics (size/resolution/other?)
of the image.
For instance:

```txt
/my/app/www/$relImgBaseDir/6/5/0/default/     // contains the default images
/my/app/www/$relImgBaseDir/6/5/0/original/     // contains the original images
/my/app/www/$relImgBaseDir/6/5/0/thumbs/     // contains the thumbs
/my/app/www/$relImgBaseDir/6/5/0/cards/     
/my/app/www/$relImgBaseDir/6/5/0/650x200/     
/my/app/www/$relImgBaseDir/6/5/0/whatever/     
```


In fact, we recommend the following image types:

- thumbs, to display side clickable photos, next to the main photo on a product box
- small, to display the products in a list
- medium, to display the main photo on a product box
- large: used to display the original photo in a fancybox/lightbox


The api should provide a way to access images, so that you basically only need to write something like this:

```txt
Api::getImages( id, type, imgType )
```

Each imageType (default, original, thumb, ...) can contain any number of images.

If you want to order them, you use natural sorting convention, because as we believe, this doesn't affect seo,
so you can do things like this:

```txt
/my/app/www/$relImgBaseDir/6/5/0/thumbs/1-kettle-bell-front.jpg
/my/app/www/$relImgBaseDir/6/5/0/thumbs/2-kettle-bell-side.jpg
/my/app/www/$relImgBaseDir/6/5/0/thumbs/3-kettle-bell-back.jpg
```

Our gui synopsis is that the product is created without images first,
and then (maybe in another tab), you have a dedicated window to handle/rename your images.
Therefore, the user can just focus on the image fileName (and not the whole path).



So that's the system we use in ekom, and if you think about it, it makes sense because:

- images are often grouped together, and so it's unlikely that you will need to control the image path
- often, all your images are located in the same directory, and so you can just import 
    them at once at the beginning (using a script for instance), and you are done migrating from another system to ekom
- Then on a daily basis, you can control the images order, and you never need to wonder where the image is 


As a drawback: if the product id changes, then you need to manually fix your filesystem; for instance if product #650
for some reason moves to product #653, you need to do the following:
  
```txt
Rename the following dir:
/my/app/www/$relImgBaseDir/6/5/0

Into this
/my/app/www/$relImgBaseDir/6/5/3
```

As a workaround, you might want to use another unique column, like the reference for a product,
but we don't have an opinion on that right now.

The ekom module should (maybe) provide you with a config array where you decide the image paths and the column being used?
 
 
Tricks. 
Last but not least, if an image starts with an underscore, it's not displayed.
This trick gives more power to the user, who now can temporarily disable an image without having to remove it from
the filesystem.

Also, to have a default image, we suggest that you use the following heuristic: if the image's fileName
contains the string: "-default", then this should be your default image.
 


For types, read the ekomApi::getImages method.






Measurement Units
-------------------

What's the problem with units?

Some attributes don't need units, like a color for instance: it's just a word; blue, red, ...
Other attributes use units, like size for instance; 55cm, 65cm, ...

Depending on the attribute, the lang and depending on the shop, you might want to use a different unit system.

For instance if you have a shop in United States and a shop in France, for the same product, you might want
to use pounds in your US shop, and Kilograms in your french shop.

That's the problem.

In ekom, this problem is handled by the api: you have a converter that does the conversion on the fly,
based on what preferences you have set via the gui.
Basically, the UnitConvertor stores your preferences in a separated file and re-use them if the
attribute/shop/lang (and maybe other criterion?) combination.
match the product you're displaying.

So, at the database level, we don't have anything about units.

That's because we try to keep the database schema as simple as possible.




Before we start digging into the details of table explanations, 
here is a summary, which is intended to be a guide for the developer/implementor.




Table and lang syncing
-------------------------
All tables ending with the "_lang" suffix should be synced with their "without _lang suffix" equivalent.

For instance imagine the **shop_has_product_card_table** and the **shop_has_product_card_table_lang** table. 

If there is three languages: fra, eng, and spa, and an entry is created in the shop_has_product_card
table, then automatically there will be three other entries created in the shop_has_product_card_lang,
one for each lang.
The implementation of the sync mechanism is transparent for the developer 
and is provided by the ekom api.

Note that if you don't use the ekom api and create/update those tables manually, you might get out of sync,
in which case the results are unpredictable.

That's because a lot of fetch/fetchAll request in the front assume that they can inner join
a table and its _lang equivalent as one atomic thing (which makes twice less requests).

In other words, the lang is the highest context in the ekom schema; when you create a lang, 
you must populate all the data for it.
If you create a new lang, it is duplicated from another.




Discounts
===========

A discount applies at the product level.


Discounts in ekom is a hybrid system, composed of a main system and an alternate system working together.

The main system is stored in the database, while the alternate system uses the filesystem.


Nomenclature.

In ekom, a discount is characterized by four properties:
 
- type 
- target 
- condition 
- procedure 


[![ekom-discounts.jpg](https://s19.postimg.org/qf3849n8j/ekom-discounts.jpg)](https://postimg.org/image/wssb7is4f/)



The type is the type of discount.
A discount can be one of the following (extendable) types:

- product: a discount applying at the product level
- productCard: a discount applying at the product card level
- category: a discount applying at the category level
- cart: a discount applying at the cart level
- ...


Notice that the first three (product, productCard and category) shape a set of products and applies to a produc, while the last (cart)
is different: it applies to the cart.


The target is the number on which the discount applies.
In ekom, in the context of there are different possible targets depending on the discount type.

- product level discount
    - priceWithoutTax
    - priceWithTax
- cart level discount 
    - shippingCost
    - taxes
    - ...



That's the target.


Condition defines whether or not the discount applies at all.
It results in a boolean.
A full language is available to express the condition.

At the time of writing, the language implementation is currently not defined, 
but we already know that you'll be able to write any condition you like: as if you were writing pure php.
So, don't worry about the power of this condition system.



The procedure is HOW do you apply the discount.
The procedure is itself composed of two elements:

- procedure_type: a technique identifier, currently:
    - amount
    - percent
- operand: an operand to work with, which signification and use depends on the procedure_type.
        For instance, if the procedure_type is amount, then the operand represents a fixed amount to retrieve from the 
        target price.
        On the other hand, if the procedure_type is percent, then the operand represents the percentage of the target
        price that needs to be removed.
- ...    
    
    
    

    
    
Ekom implementation of discounts    
--------------------------------


### prelude

[![ekom-discount-prelude.jpg](https://s19.postimg.org/5p3j518tf/ekom-discount-prelude.jpg)](https://postimg.org/image/3kj63y76n/)

There are different characteristics related to how a discount applies to a product that I didn't know
(and learned the hard way) that I would like to share with you, or with another version of myself in
the future.


In this section, we will use HT and TTC as abbreviations for price without tax and price with tax 
respectively, those come from french language by the way.



First, we have two types of (product) discounts:

- fixed amount (aka amount) discounts
- percent discounts


Then, a discount is always applied on a side, which can be either the HT side or the TTC side.

It's possible to apply multiple discounts to a given product.


Applying a fixedAmount discount on the HT side doesn't give us the same final price as if the discount
was applied TTC side (the ekom prelude figure illustrates this).

It turns out that percent discount can be applied on either side interchangeably (due to some
mathematical properties of percentages I guess).

In the same order of idea, a tax group (which is a combination of percent rates applied to a price)
doesn't alter this special property of percentages (see ekom prelude figure).

Finally, even when mixed in multiple discounts, percent discount keep this special property.



One of the problem we try to address with the ekom prelude figure is to define the set of data
that we should provide to template authors for a product page.

This set of data is complex because what we want to display is complex:

- we want to display not only the price, but also badges (potentially).

A badge is a circle or rectangle with a text inside indicating the savings made by one or multiple discounts.
The saving can be expressed either as a fixed amount or as a percent.

For instance, -8€ or -20€.
Also, we can have compound badges; those badges sum up the savings made by a sequence of multiple discounts
applied on the same product.
A template author should be able to display the details of all badges if she wanted to, or just one compound
badge summing them all.


So, the variety of badges itself is part of the complexity.

Added to that, we have to take into account that the price can be displayed either without taxes, or with taxes.


And so basically the set of data that we provide has to allow template authors to display all possible display variations.
Yet, we don't want to overwhelm template authors with too much data, otherwise there is the risk that they won't 
understand the model.


So let's continue this brainstorming here.

#### Principle of badge polymorphism

A badge content (of type amount) will adapt its content depending on the side we're on (HT or TTC).
This will simplify the model for template authors, which otherwise would need to make conditions (try to avoid that
as much as possible is our rule of thumb). 

Note that as we've discussed earlier, percent badges won't actually need to change since their value is the 
same on both sides.

In case an author wants to create a debug template displaying all details of a multiple discount,
we provide the multiple discount details (see how it looks in the product-box.md document). 
 
 
#### Principle of display freedom

Ekom deliberately doesn't provide too much display rules, so that the theme is king.
We have one rule (which can also be violated by the way): displayPriceWithTax: true|false, and that's it.

If we had more rules, or should I say display modes (like for instance displayBadges: true),
we would put the template author in a jail.
 
 



So, the basic idea is that most template authors can get away with this kind of snippet for displaying the price:

```php
<?php if (true === $hasDiscount): ?>
    <div class="displayPrice oldprice linethrough">120</div>
<?php endif; ?>
<div class="displayPriceDiscount">100</div>
<div class="badge percent-badge compound-badge">20%</div>
```

So, the price and oldprice (note that the oldprice might be hidden depending on whether or not the price HAS a discount).
And one compound badge to tease the customer (or whatever you think of what a badge does).












 
 



### multiple discounts

We can have multiple discounts applying to the same product.

For instance, you can have a -5€ discount AND a -10% discount applying to the same product.

However, the percentage won't merge, they will apply sequentially, 
because semantically they are DIFFERENT discounts.

This means you can have those discounts applied to a product:

- -20%
- -10%

But you can not combine them in one -30% discount with this system, because that's not
the philosophy.


So if you want to merge percentages, you need to do it manually (upgrading the old percentage for instance),
or using other heuristics.
    
    
    

    
### --    
In ekom, we use both the database and the filesystem to provide a discount system to the shop owner.

The database takes care of the most of the job, and the file system is an 
extra layer to helper with complex conditions that the database part cannot handle.


Indeed, the filesystem is all powerful, as one can guess from the example below:
    

Code example
---------------
```php
<?php

// this is an example condition that you can write
$date = date('Y-m-d');


$target = "priceWithoutTax";
$condition = "date between 2017-05-25 an 2017-06-31"; // just for the user and gui
$condition = ($date > "2017-05-25" && $date < "2017-06-31"); // used concretely by the prod application
$procedure = [
    "type" => "",
    "operand" => "5",
];






// this is an estimate of what should be generated by ekom from the code above
$cb = function (array &$model) {
    $date = date('Y-m-d');
    $model['priceWithTax'];
    if ($date > "2017-05-25" && $date < "2017-06-31") {
        $model['priceWithoutTax'] -= 5;
    }
};
```


However, to modelize conditions in database, we have reduce the spectrum of conditions to a few filters
which generally do the job.

Those filters are:

- user_group
- currency
- date_start
- date_end

This basically means that the database will let you create a condition based on whether the user
has a certain group, or if the currency is of a certain type, or whether or not the date is
in a given period.

Note: for this database model, the discount type (product, productCard,...) is inferred by the table relationships.
See the discount table and related tables for more information.



    
    




Seo
=======
http://www.thesempost.com/new-title-description-lengths-for-google-seo/

- meta_title: 70 chars
- meta_description: 100 chars (-> 156)






Cached data
============
Sometimes, ekom stores data in the database that isn't strictly required, but serves the purpose
of making request more efficient/faster.

Those columns of type "cached" always begin with an underscore.

If a column doesn't start with an underscore, it's not a cached data.







Order of precedence for products label and description
=====================================

- shop has product
- shop has product card
- product
- product card


This is used in the following methods:

- ProductLayer.getProductBoxModelByCardId
- ProductCardLayer.getProductCardsByCategory





So now you're ready to read...


THE TABLES EXPLANATIONS
=============


ek_lang
=========

Lang for the front office.

Strings that come from the database can be translated.

The lang table handle those translations.

We generally add the "_lang" suffix to a table to isolate the translatable columns
from the core table (the table without the "_lang" suffix).

A shop (front office)'s default lang is defined in the shop table.

The backoffice's lang is defined in the backoffice_user table, but it doesn't use the lang table,
rather it uses the application's native translation system.


- label: english label for the lang
- iso_code: a 639-3 iso code http://www-01.sil.org/iso639-3/codes.asp  (3 letters code)






ek_backoffice_user
================

- email: we might need to alert that user, hence the email instead of a simple login
- pass
- lang_iso: the preferred language for this user (using iso 639-3)
            
            
            





ek_currency
=========
- iso_code: iso code 4217
- symbol: the symbol representing the currency (for instance $)



ek_timezone
===========
- name: english name of the timezone




ek_shop
=========

This represents a virtual store.

It holds the configuration of your e-commerce.

In ekom, for now we identify the front office shop by the host.


A shop controls the products at an administrative level (enable/disable a product
is a per-shop operation).
 
 
 
- label: a label to identify the store in the backoffice (not displayed in front)
- host: null|string, the host used to identify the front office shop (if null, other heuristics are used to select the front office shop).
- lang_id: fk|null, the default lang used for this shop in the frontoffice (the backoffice lang being set in the backoffice_user table).
                If null, use the heuristic you want, like using the user's browser's lang for instance.
                
                
- currency_id: fk, the base currency.
                    The base currency is used in the backoffice to determin prices.
                    So when you create a product, it's price is given in this currency.
                    It is used as the reference for exchange rates.
                    
                    The base currency is also the default (the user can change it) currency used for the front office.
                    
                    This currency must be set in the shop_has_currency table, and with the column active set to 1.
                    
                    
                    
- timezone_id: fk, the time zone used by this shop on both the front office and backoffice.
                    It cannot be changed by the user, it's the owner decision.





ek_shop_configuration
====================

This is an extension of the shop.
Basically, providing a dynamic structure for modules/plugins to hook in.


- shop_id: pk
- key
- value



ek_shop_has_lang
====================

The languages available to the front office.


ek_shop_has_currency
====================

The currencies available to the front office.

- exchange_rate: the exchange rate of the currency compared to the base currency.
                    It answers the question: how many of this currency do you get for one unit
                    in the base currency.
- active: 1|0


Note: http://www.xe.com/currencyconverter/





ek_product
===============

The product represents a unique product, that is a product with a unique set of attributes.

The product might be physical or downloadable.
Use a weight of 0 for downloadable objects, 
this might be an indicator for calculating shipping costs for this product.


The product might have no attributes at all.


- reference: uq, the unique reference                
- weight: the weight in kg for the product, or 0 if the product has no weight (like a downloadable product for instance).
                This is the weight used to compute shipping costs.
                
                
- price: the base price without tax for this product.
                This price can be thought as the suggested price, or catalog price, and
                can be overridden by the seller on a per-shop basis using the shop_has_product table.
- product_card_id: fk, the product card this product belongs to.
                    Even if you store sells only products (not product cards), you need to create at least
                    one product card, which semantically represents the canonical/abstract version of your product.
                    The canonical version is easier to manipulate in various cases (that's why we need it).

                        
                        






Why weight in kg? 
Because we want to keep it simple, and so handling only one unit is simple.
Template authors should use functions in their templates if they need another unit.
Now, kg is a unit everybody knows well (I believe, please tell me if that's not the case).

https://en.wikipedia.org/wiki/International_System_of_Units

Okay, but what if all my products are in pounds, like my main product weight exactly 1 pound (I intentionally 
created it that way because 1 pound is my selling argument... blabla).
Ok, don't worry, this weight is just for shipping costs, it won't be display.
So, use a convertor for now (or a script afterwards if it makes more sense to you).
 
Then if you want to expose your weight to the customer, you should use "product_attribute".
There you have control about the measure unit being used.
                
                
            
ek_product_type
==================

Each product has a type.
A default type should be created for every shop, which should be named "default".
Adding a type to the products allow modules to hook in at the product level logic.
It was added at 2017-07-04 to allow the EkomTrainingProducts module to implement its logic.
The EkomTrainingProducts module sells trainings as a product.
A training has a few characteristics that aren't really attributes nor features, such as
the starting date of the training, which renews itself every year (and might be different
from a year to another), and the location where the training was performed.

By giving the "type" field to the module, the module can recognize its own "training products"
and do special things, using the regular ekom hooks.


- id: pk    
- name: uq    
- shop_id: uq    
    







ek_product_lang
===============

- label: string, the base/default label for the product
- description: string, the base/default description for the product
- meta_title: string, the base/default meta title for the product, if empty, ekom uses its own heuristics
- meta_description: string, the base/default meta description for the product, if empty, ekom uses its own heuristics
- meta_keywords: array(serialized), the base/default meta keywords for the product, if empty, ekom uses its own heuristics
- product_id: fk
- lang_id: fk



ek_shop_has_product
==================

The products are available to a shop.


- shop_id: fk
- product_id: fk
- price: null|string, the price of the product for this shop, or null to use the base price from the product table
- wholesale_price: number, the price of the wholesaler, useful if you want to later make stats on how much benefit you made
- quantity: -1|0|int, the number of items left. If -1, it means infinite (for downloadable products for instance).
                        If 0, it means out of stock. 
                        Any positive number indicate the number of units left.
                        In other words, if the quantity is 0, it means out of stock, and otherwise it means in stock.
                        
                        Note: in the previous schema, the quantity was assigned to a store entity (which has been removed
                        in this new schema for simplicity).
                        This means if you want something more complicated, you need to add your own plugin.
                                                
- active: 0|1, whether or not the product is available for the shop
- _sale_price_without_tax: number, the sale price of the product. It's a cached data.
                        The problem we had is the following:
                        
                        we want to display the list of products.
                        This list can be filtered by different criterion, including price (sale price).
                        The problem is that the sale price depends on the discount, which usually is computed
                        dynamically everytime (because a discount potentially depends on conditions which involve
                        cache-unfriendly things like the date for instance).
                        
                        So without the salePrice in the database, the only way we can select all products 
                        which price is between 10 and 100 is to actually compute all cards, then compute
                        every discount.
                        Only then we can start limiting the items, manually.
                        Performance wise, this approach is a nightmare.
                        
                        Now with the _sale_price column in the database we can use the mysql filtering
                        power of the where clause at its full potential,
                        and thus use the natural limit clause to paginate our request and limit the results
                        to the subset we are interesting in.
                        It turns out that the current implementation still recompute the model for every card,
                        but that could be changed in a near future, and it's less dramatic with 20 items than 
                        with 200 anyway.
- _sale_price_with_tax: same as _sale_price_without_tax, but with tax                        
- seller_id: fk, the seller of the product                        
- product_type_id: fk, the type of the product                        
                        
                        
                        
                




ek_shop_has_product_lang
==================

Allow override of the label and description (of the product_lang table) for a given shop and product.


- label: string, the overriding label of the product, or empty to use the base label from the product_lang table
- description: string, the overriding description of the product, or empty to use the base description from the product_lang table

- meta_title: string, the overriding meta title of the product, or empty to use the base meta title from the product_lang table
- meta_description: string, the overriding meta description of the product, or empty to use the base meta description from the product_lang table
- meta_keywords: array(serialized), the overriding meta keywords of the product, or empty to use the base meta keywords from the product_lang table

- out_of_stock_text: string, the text to display when a product is out of stock.
                        Note: there is no text for when the product is in stock, because there is very little
                        chance that the "in stock" text varies depending on the product (and if it does you can
                        always handle this in your code).
                        
                        Note2: @plugins authors: if you want a time based automatic string (I thought about that),
                        you can create a restock_calendar table, which could contain the product_id, and the estimated
                        date of restock.
                        
                        Note3: we set the out_of_stock_text in the database rather than writing it directly
                        in the template in the event that the out of stock text contains time based information
                        (for instance: this product will be available in 6 days).
                        
                        With this base version, we consider this an advanced feature.
                        
- slug: string uq, an unique (per lang) or empty url friendly identifier that can be used by the application to identify a product using the url
                If the slug is not set, then the reference of the product table should be used.










ek_product_attribute
=============

Attribute for a product. 

Attributes can be re-used by different products.

- name: uq, the unique name for an attribute





 

ek_product_attribute_lang
=============

Translation table for a product attribute. 

- name: string, the translation for a product attribute
 



ek_product_attribute_value
=============

Value for a product attribute. 

Values can be re-used by different product attributes.


- value: uq, a unique product attribute value, it's like a slug for attribute value really, if we need it
                    (if we don't we can simply use the id)
 


ek_product_attribute_value_lang
=============

Translation table for product attribute values. 

- value: string, the translation for a product attribute value



ek_product_card
=================

This represents the canonical product: the one humans generally refer to, the "abstract" product.

This is often the product card that we showcase when we want to sell a product.



ek_product_card_lang
=================

- label: the label for this product card
- description: the description for this product card

- meta_title: the meta title for this product card, is only used if not defined at the product level (it's a fallback)
- meta_description: the meta description for this product card, is only used if not defined at the product level (it's a fallback)
- meta_keywords: the meta keywords for this product card, is only used if not defined at the product level (it's a fallback)


- slug: string uq, a default unique (per lang) url friendly identifier that can be used by the application to identify a product card using the url
- product_card_id: fk
- lang_id: fk


Label, description and slug can be overridden at the shop level with the shop_has_product_card_lang table.





ek_product_has_product_attribute
=================

Binding product to attributes.

Note that products are bound to attributes and values regardless of the 
shop (but the shop can decide to sell the product or not to sell it).


The synopsis is that the user first creates a product.
This will automatically create the parent product card at the same time.

Then, the user can "Create a new variation of this product", which 
basically creates another product in the same product card, sharing the same attributes (but different values).

Hence, if on the front you want to display the list of all attributes and attribute values
for a given product card, you need to first take the list of all products belonging to that card (product card),
and then look into this product_has_product_attribute table, searching for all attributes and values owned
by this list of products.


Also there is the order field.
Note again that the order doesn't belong to a shop, which means all attributes in all shops will be ordered
the same way.
If that's too much a constraint, you can always override this order value by one of those, but we recommend
not to do that unless you've got a very good reason to do so, and if you know exactly what you're doing.

The order appears to be a determinant factor in displaying attributes on the productBox.
See the ekom notes in the AttributeSelectorHelper class, used by the ProductLayer class.
 





PRODUCT LAYER
===============

On the mysqlWorkBench schema I drew a product layer around the following tables:

- product
- product_lang
- product_has_product_attribute
- product_attribute
- product_attribute_lang
- product_attribute_value
- product_attribute_value_lang
- product_card
- product_card_lang


This "product layer"'s tables can be seen as one atomic table representing one product entity.

That's to emphasize that first, a product is really a combination of a reference
with a unique set of product attributes.
That is, if you change one of the product attribute/product attribute value, it's ANOTHER product.


Then second, a product card is a well defined ensemble of products that share the same attributes.

This product layer doesn't depend on the shop!

That's why the product_has_product_attribute table doesn't depend on the shop:
a product exist as is, as a physical product with physical characteristics,
and then a shop can decide to own/sell that product or not, using the shop_has_product table.

Same with product card: the product card is bound to the products as you would say a "red Stenhal Chair" and
a "blue Stenhal Chair" are both a "Stenhal Chair", red and blue variations being products, and the "Stenhal Chair"
being the product card. This does not depend on the shop, it exists by itself.






ek_category
=================



A shop can create categories to organize product cards.

Those are breadcrumbs categories.

They help to display the breadcrumbs, and maybe other things.

In the logic of the breadcrumbs, ideally, each product card should have a category,
otherwise, can you imagine a product without breadcrumbs?


- name: uq, the functional/canonical name of the category, could be used by developers 
- category_id: null|fk: the id of the parent category if any, null means it's a top level category 
- shop_id: fk 



ek_category_lang
=================
- label: the translated name for this category       
- description: a translated description for this category       
- slug: uq, the slug for this category. Ideally, the unique index would have been on a shop and a lang.
                However, we didn't manage to make it happen in the db schema, so technically speaking the unique index is
                only bound to the category_id and the lang_id.
- lang_id: fk       
- category_id: fk       

- meta_title: string, the meta title for this category, or ekom uses its own heuristics if empty
- meta_description: string, the meta description for this category, or ekom uses its own heuristics if empty
- meta_keywords: array(serialized), the meta keywords for this category, or ekom uses its own heuristics if empty



ek_category_has_product_card
=================




ek_shop_has_product_card
=================

A shop owns a product card, and thus can control the information on a product card.
The shop can also enable/disable a product card.

If a product card is not found in this table for a given shop, it basically means that the although
the product card might exist in the catalog (product_card table), it isn't attached to the shop yet.
A message like: "The requested product is not associated with this shop" should do it (notice that we used
the term product instead of product card, because the user doesn't know about the ekom implementation details).

Now, if an entry exists but the active column is zero, a message like:
"Sorry, the requested product has been de-activated" should be displayed.




- shop_id: pk
- product_card_id: pk
- product_id: fk, 
            the product used as the main reference (or the representant) for the card.
            Ekom ensures that there is always at least one product in a card.
- active: 1|0, the product card should not be displayed if this is set to 0
            


ek_shop_has_product_card_lang
=================            

This table contains the info that can override the default values of the product_card_lang.
This table is synced with the shop_has_product_card table.






- shop_id: pk
- product_card_id: pk
- lang_id: pk
- label: string, if not empty overrides the product_card_lang.label
- slug: string, if not empty overrides the product_card_lang.slug 
- description: string, if not empty overrides the product_card_lang.description
 
 
- meta_title: string, if not empty overrides the product_card_lang.meta_title
- meta_description: string, if not empty overrides the product_card_lang.meta_description
- meta_keywords: array(serialized), if not empty overrides the product_card_lang.meta_keywords






(about tax)
===============
The tax is a complex topic, as a tax can be applied depending on various parameters:

- the user type (b2b, b2c)
- the seller location
- the shipping location
- the product type
- period of the year (1)
- amount of revenue (2)
- amount of carbon dioxyde released in the air (4)
- ...


Sources:
- (1): https://www.youtube.com/watch?v=ow_XePUF-fI
- (2): https://www.youtube.com/watch?v=6ySnl1YTnLU
- (3): https://www.youtube.com/watch?v=7cVj9Jevn28
- (4): https://www.youtube.com/watch?v=7Qtr_vA3Prw





But in the end, the tax can be modelized as a percentage added to the price of a product.

To make the model flexible, we use conditions to determine whether or not a tax applies to a given product.

A condition is a string using the ekom condition syntax (see the ekom condition syntax section for more information).

If a tax is not bound to any conditions, then it applies.




ek_tax
=========

Tax represents any tax that you eventually want to apply to a product.

- amount: the amount of the tax in percent



ek_tax_lang
=============
- label: 



ek_tax_group
==============

A group of taxes.
In fact, you can bind product cards only to tax groups, you cannot bind product cards directly to taxes.

- label
- condition: ekom condition syntax, empty string will validate


ek_tax_group_has_tax
=========
- order:
- mode: defines how the tax are compound together (in case of a group with multiple taxes).
            Possible values are:
            - (empty string): alias for chain
            - merge: merge with the previous tax before applying to the target price
            - chain: apply on the previous tax's result 


ek_product_card_has_tax_group
=========

For a given shop, a product card can be assigned ONE and only one tax group.

- shop_id: pk
- product_card_id: pk
- tax_group_id: fk
 
 

Note that we bound a product card to a tax group, and not a product to a tax group.
That's because we believe in 99% of the case that's what one will need, and therefore we
save some entries in the database.

However, if that was the case that different products in your shop are assigned different tax groups,
then you could use the condition system to do achieve what you want.

Or consider creating a dedicated product card for the product causing the problem.




ek_user
===========

A user is owned by a shop.
It means it's the user of shop A by default needs to recreate an account to log in shop B.
Ekom could/should provide a "multi-pass" (sort of) option to auto-duplicate the user account to all shops
if that's something all the shop owners are willing to accept.


- shop_id: fk, uq1
- email: uq1, the user's email, used as a login
- pass: the user's password
- pseudo: the user's pseudo for the comments, as the first name and last name of the user might be confidential data
- first_name: the user's first name
- last_name: the user's last name
- date_creation: the datetime representing WHEN the account was created
- mobile
- phone: suggested is the following notation, called ekom phone notation:
            phoneNumber: <localPhone> | <internationalPhone>
            localPhone: <localNumber>
            internationalPhone: <callPrefix> <:> <localNumber>
            localNumber: any number of digits
            
            For instance: 33:0247609841
            Or: 33:247609841
            Or: 02 47 60 98 41
            (depending on whatever the user typed for localNumber)
            
            
- newsletter: int(0|1), default=0, whether or not the user is willing to receive newsletter from the application.
- gender: int: a number representing the gender: 1: male, 2: female
- active: int(0|1), default=0, whether or not the user is active.
                    If the user is not active, she cannot connect to her account.
                    When the user creates an account via the front, the default becomes 1.




ek_user_group
===========

The user group is an organizational unit that allow us to apply rules to a group of users at once.
Typically, some discounts applied to a certain group of users.

- name: uq, the (bo) name of the group
- shop_id: fk



ek_user_has_user_group
===========


ek_password_recovery_request
===========

Keep track of requests initialized by users for resetting their passwords.

- id: pk
- user_id: fk
- date_created: datetime, the date when the token was emitted (token might have an expiration date)
- code: a hash to ensure that the user is really who she claims to be
- date_used: nullable datetime, the date when the user used her token to reset her password



ek_user_has_product
=====================

Represents the user's wishlist.

- id: pk
- user_id: fk
- product_id: fk
- product_details: text, serialized version of the product details if any
- date: datetime, date at which the product was added



ek_discount
===========
- user_group_id: fk|null, if this is set, the discount only applies if the user belongs to that group (participate to the discount condition)
- currency_id: fk|null, if this is set, the discount only applies if it matches with current currency (participate to the discount condition)
- date_start: datetime|null, (participate to the discount condition)
- date_end: datetime|null, (participate to the discount condition)
- procedure_type:
- procedure_operand:
- shop_id: fk


Note: to use the hybrid system, take the id of the discount, and create a corresponding file containing the 
condition written in php. Details will be provided later when this feature will be used for the first time.
 
Note2:
If date_start and date_end are both not set, the currentDate will always match.
If date_start only is set, the currentDate will match only if it's past that date_start
If date_end only is set, the currentDate will match only if it's before that date_end
If date_start and date_end are both set, the currentDate will match only if it's between those date_start and date_end (including).
    
          

ek_discount_lang
===========  
- discount_id: pk                    
- lang_id: pk                    
- label:                     




ek_product_has_discount
===========  
Infers the discount type of product (see the discount section at the top of this document for more details).
- order_phase (see order phase note below for more information)
- active: 0|1

ek_product_card_has_discount
===========  
Infers the discount type of product_card (see the discount section at the top of this document for more details).
- order_phase (see order phase note below for more information)
- active: 0|1

ek_category_has_discount
===========  
Infers the discount type of category (see the discount section at the top of this document for more details).
- order_phase (see order phase note below for more information)
- active: 0|1





Order phase note
--------------------
It's possible to set discounts at the product level, product_card level and category level.
The problem is that those three types of discounts do the same thing in the end: they apply
to a set of products.

Therefore, we have potential discounts conflicts.
 
Yet, the shop owner should be able to do any shaping she wants, including:

- all products in the category X have discount A, except productCard 45 and product R8


So, the order_phase let the shop_owner do that.

How does it work?

The order_phase  put all three discount types in the same ring for the battle: only one winner for a given order_phase.
And the winner is the most specific (product, then productCard, and category).

So, this means if you set discount A at the three levels with the same phase (order_phase) of 0 (for instance), then only
the product discount will apply.

This means, if you want to do the example I gave above, you would set the discount A for the category X at phase=0,
then for the productCard 45 at phase=0, then for the product R8 at phase=0.

Now, order_phase also works as an ordering tool to allow parallel discounts (because your shop owner might want to cumulate
two discounts for some reasons, right?).

So, the discounts are applied by order_phase asc.  






ek_order
=================

Related notes in cart-checkout-and-order.md.

The order table records the proof of users' intent to pay the shop owner.
Proof that has some juridic value (in case something goes wrong).


- user_id: fk
- reference: 
- date:
- tracking_number:
- user_info: a serialized array containing the following info:
    - id (just in case), email, mobile, phone, pro (a plugin needs to put this field here), group label.
            
- shop_info: a serialized array containing the following:
    - id, label, currency_symbol, currency_code


- shipping_address_info: serialized array with the following:
    - invoice_country
    - invoice_state: 
    - invoice_city
    - invoice_postcode: varchar  (some postcodes contain letters)
    - shipping_address 


- billing_address_info: serialized array with the following:
    - billing_country
    - billing_state
    - billing_city
    - billing_postcode: varchar  (some postcodes contain letters)
    - billing_address 

- order_details: a serialized version of the ekom order model, as defined in the appendixes of this document
            Plus, it should contain the user coupons information (the coupons used by a user for this order).




ek_order_status
================

Contains the statuses used by ekom.
States can be created by plugins and modules, or manually, on a per-shop basis.


- code: a code representing the status of the order. 
            Note to ekom devs, every time a new shop is created, the order statuses for that shop should be created
            as well.
            By convention, we use camelCase for codes.
            
- color: a color code for the order status            
- shop_id: fk
            
            
For codes, there are different sets of codes that a shop owner will want to use,
depending on her business type.

Our approach in ekom is to let the shop owner choose a statusProvider, which ekom will fetch the codes from.
For instance, when the order is placed, ekom will ask the chosen statusProvider: what code should I use now?

Then, when the payment is confirmed, ekom will ask: what code should I use now?

And so on...


Therefore, devs should know about WHEN ekom ask those questions, and WHAT it means.

This information can be found in "class-modules/Ekom/Status/Action/EkomStatusAction.php".


                        
                        

ek_order_status_lang
===================
- label:

            
ek_order_has_order_status     
=======================

This is an history of status.
The current status for a given order being the most up-to-date status.



- id: pk
- order_id: fk
- order_status_id: fk
- date: datetime
- extra: 





ek_coupon
===========

A code is entered by the user and triggers a cart discount if the code condition matches.
The code condition is stored in the filesystem for now, in a file which name is based on the
shop_id and the coupon code (it could also be stored in the database, but I believe the filesystem offers more 
possibilities since we can use the full php language in an editor, at least we developers).

- code: uq1, a unique (per shop) code, like abc for instance 
- shop_id: fk|uq1  
- active: 0|1, whether or not the code is active.
                If active is set to 0, the user won't be able to add it.
                However, once the bindure between the coupon and the user is made,
                the coupon is always active, independently of the active value.
                
                In other words, this active field only serves as a "door keeper".
                Once you are in, you are in for good.
                
- mode: define how the coupon behaves with other coupons, or with the same coupon added multiple times.
            The metaphor is that each order or potential order is attached a coupon bag.
            The user can put one or more coupons in her bag.
            
            The following modes are available:
                - unique: the coupon cannot be used in combination with other coupons (including one with the same code).
                            If one or more coupon(s) already exist in the bag when the unique coupon is added,
                            the unique coupon will replace the other coupon(s) if its priority number (the priority
                            column of this table) is greater or equal than the highest priority number in the bag.
                            Otherwise, the unique coupon will be rejected/ignored.
                            
                - mergeWithSame: the coupon is only added if the bag contain only coupons with the same code, or no coupons at all.                            
                - merge: the coupon is always added to the bag.
                                            
            If empty, unique is assumed.                                            
                                            
- priority: int, a helper number for mode (see mode column explanations for more details)


ek_cart_discount
=================

The cart discount table stores a procedure which can be applied to a target price to raise/reduce it.

- target: specify the target price.
                This is an extendable field.
                The values provided by ekom are:
                
                - linesTotalWithTax
                - linesTotalWithTaxAndShipping
                
                (see ekom order model II to see where they apply).
                This value must be specified (a non empty value is not valid).

- procedure_type: the type of procedure to apply, can be one of:
                    - fixedAmount: replace the targetPrice with the procedure_operand value
                    - relativeAmount: affect the targetPrice by the procedure_operand amount (which can be negative or positive)
                    - relativePercent: affect the targetPrice by a percentage defined by the procedure_operand (can be negative or positive)
- procedure_operand: a helper for the procedure_type field
- shop_id: fk


ek_cart_discount_lang
========================
- label: 
                     
                     
                     
ek_coupon_has_cart_discount
========================
                     

                     
ek_country
============
- iso_code: ISO 3166-1 alpha2 code
     https://en.wikipedia.org/wiki/ISO_3166-1

    

ek_country_lang
===============
- label: string
- country_id: pk
- lang_id: pk





ek_address
============

- first_name: string
- last_name: string
- phone: string, the phone prefix is not there because it can be guessed from the country
- address: string
- city: string
- postcode: string
- supplement: string, things like box code, or the c/o mention
- active: int(0|1|2), 2 means deleted. One shall not be able to recover from deleted.
                    A deleted entry stays in the table so that when the user
                    sees her orders, we can dynamically track back to the address information
                    simply using the address_id (which was not deleted).
- country_id:fk



ek_user_has_address
====================

In ekom, you don't make a difference between shipping and billing address until
you need to ship an item. This means every user has an address book, and each of which 
can potentially be of any type (billing and/or shipping)

- user_id: pk
- address_id: pk
- order: int, display order
- is_default_shipping_address: 1|0
- is_default_billing_address: 1|0








ek_carrier
==========
- name: abstract name, used to find the corresponding class provided by the ekom application



ek_shop_has_carrier
==================
- shop_id: fk
- carrier_id: fk
- priority: int, priority number (usually ordered from the cheapest for the user to the most expensive).
                    Lowest number has precedence.



ek_shop_has_address
====================



- user_id: pk
- address_id: pk
- type: string (physical), the type of the shop address, the following values are available:
        - physical: the physical address of the store, this is the default address used by ekom 
                to estimate the shipping costs of a non connected user.

- order: int, just in case, isn't used yet



Note to ekom implementor: a shop should always have a physical address attached to it (i.e. don't create a shop
without a physical address).




ek_payment_method
================
- name: uq, name (identifier) of the payment method


ek_shop_has_payment_method
================
- shop_id: fk
- payment_method_id: fk
- order: int, the lowest order is the preferred method payment for this shop
- configuration: text(serialized), some payment methods require configuration (for instance a paypal key, etc...)





ek_product_comment
================
- shop_id: fk
- product_id: fk
- user_id: fk
- date: datetime
- rating: number: from 0 to 100, representing a percentage
- useful_counter: int: how useful is this comment
                    Whether or not anonymous users are given the right to increment this counter is up to the application.  
- title: string (128): the title of the comment. Not mandatory, but can be useful to some people
- comment: text
- active: 0|1, 0 means not visible, 1 means visible





ek_product_has_feature
=====================

Note: a feature to all shops,
but then each shop decide which feature/values it defines on a per-product basis.
This way, we can have the same products with different features depending on the shop,
and yet we have shared pool of features and values, so that we don't waste too much storage in the database.


- product_id: pk
- feature_id: pk
- shop_id: pk
- feature_value_id: fk
- position: to ordre the features in the front



ek_feature
============

Note: a feature to all shops.

 
 


ek_feature_lang
============

ek_feature_value
============

ek_feature_value_lang
============



ek_product_bundle
===================
A bundle is a bunch of related products suggested by the shop owner.
We typically display them below a product box.

The user usually can add/remove items from the bundle as she wishes.

When the user adds the bundle to the cart, all products of the bundle
are added at once.



- active: 0|1


ek_product_bundle_has_product
===================
- product_bundle_id: pk
- product_id: pk



ek_product_card_combination
=====================

A product card combination helps creating a product composed of a fixed immutable set of product cards.

The user cannot add/remove product cards from the combination; the product cards combination
is set by the shop owner and cannot be changed.
Even the quantity is fixed.

So, the user either takes the whole combination or takes nothing.

This is mostly useful for product cards which price doesn't change depending on attributes.

Note: If the price changes depending on attributes, you might want to use/create a "ek_product_combination" similar mechanism.


Typically, the card combination is displayed as an alternate form of the product box.
The items of the combination are displayed on a right sidebar, and there is an "add to cart" button
at the bottom of that sidebar.

The user can changes the attributes of every card, and then add the whole combination to 
her cart in one fell swoop.

The logic, from ekom's perspective, is that if a product has a product card combination,
then the "product card combination box" should be displayed, otherwise the regular product box 
should be displayed.



- id: pk
    The idea as for now is that a given product can only have one combination.
    However, in anticipation of some potential evolutions on this, a product card combination
    has its own id and so technically there can be more than one product combination per product.
    Ekom should prevent you from creating multiple combinations for now, as it's not useful yet.
    
- product_id: fk
- shop_id: fk



ek_product_card_combination_has_product_card
=====================
- product_combination_id: fk
- product_card_id: fk
- product_id: fk, nullable, a default product to select.
                    If null, then this means that no particular attributes configuration
                    is preselected.
- quantity: int








ek_seller
==================

The seller information can be displayed on the front: "sold by MyCompany".

- id: pk
- name: uk, the seller (symbolic) name
- shop_id: uk,fk




ek_product_group
================

A group of products, so that you can do actions on them.
It was initially created in order to showcase feature products on the front (in a carousel).
Then it was also used to create related product groups.



- id: pk
- shop_id: fk
- name: uk, the name of the group.
            If the group starts with the colon symbol (:),
            it's reserved for the ekom system.
            For instance, ekom use the ":related-" prefix followed
            by a card id to implement its related product system.





ek_product_group_has_product
================

- product_group_id: pk
- product_id: pk
- order: int









Ekom condition syntax
=======================

This is a mini-language that basically allows the shop owner to use the power of php 
to express conditions.

Conditions are used to determine whether or not a discount applies for instance,
or whether or not a tax group applies, those sort of things.


The goal is to let the owner do things like these:

```txt
- country.iso = fra
- product.type = physical (not virtual)

(if)
price > 20
& cart containsProduct 452
|| ( cart hasMinAmountOf 100 && cart hasMaxAmountOf 500 )
& ! user.country isEqualTo France
```




HELP for the implementor
========================


Product Box
===============
Here is what we recommend for a product box:

The product box shows a product contained in a product card.

When available, the product info have precedence over the product card info.

Those info concerns the following:

- images: first search in the product hashed directory, 
            then also search in the product card hash directory, 
            and stop searching when your max number of images is reached.
            
            A has directory is based on the id of the product/productCard.
            For instance, a product with id 12345 will have its images in the 
            app/www/product/1/2/3/4/5 directory.
            
            Read the "No images" section above for more details.
            
- label: if the product label is not empty use it, otherwise use the product card's label
- description: same as label







Slug
---------

slug is a string used to identify an item via the url.
The goal is to have pretty seo friendly urls rather than numeric ugly urls.

A slug depends on the language of the shop.

The product slug is defined at two locations:

- At the product card level
    - first check the slug in ek_shop_has_product_card_lang,
    - if empty use the slug in ek_product_card_lang
- At the product level
    - first check the slug in ek_shop_has_product_lang
    - if empty, use the reference in the ek_product table



