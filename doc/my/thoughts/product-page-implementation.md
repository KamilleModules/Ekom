Product Page implementation
===================
2017-09-18



So let's get those hands dirty!
(sounds like a slogan)




Handling the Static and dynamic part
======================================

-> Let's create a refreshBoxModel global js function.

This function will simply call the appropriate ajax service.
As explained in the product page document, the only thing we need to do is collect the right params, to emulate
the static uri.

So, if we have product details, we can either pass the product details or a token.

The refreshBoxModel function also needs to know which product id to call (which identifies
a unique combination of attributes).



About the service called
-----------------------------

When you call the ajax service from the template in order to update the current 
page, you can either:

- call json data, inject the data with js
- call html data and inject the data directly
- there are other options like using a framework that makes bindings (angular, react..),
        but in ekom I won't use them (they are too fancy for me, and no time to investigate
        at this time of the year)



Calling json data is what I did in my previous attempts,
but it requires that you make the view twice.
The one that you cannot avoid is the static view, generated by php.
The second one is the js template: you need to recode part of the static view
that you want to change.
In some cases, although not hard at all, it's time consuming.

The html option was appealing, injecting directly the html fragments in the view.
The obvious benefit is that you can then factorize the generator of the view fragments.

One drawback is that to display something we need to make an extra ajax call which
is not necessarily required with the js technique (thinking about the update cart area).
So, I won't probably use it, since I prefer performances over a longest development time.

But here is my two cents about the html technique though.

In my mvc implementation, js comes from the view, so js belongs to the template.
In other words, to me the gui behaviour of a page is view dependent.

In other words ajax calls are just another tool in the view's arsenal.
And so using json or html is just a matter of tastes.

That's it for my alibi for using html, now to the implementation.


### Implementation

To make things easier for me (and everybody following my steps), I will create the following
convention:


- a theme that uses this technique of fetching html fragments should put all its fragments
    in a fragments directory, direct child of the application root directory
    
- then we can call the module's html service to access it


So the directory structure should look like this:

```txt
- app
    - fragments
        - $ModuleName
            - $fragmentId.php
    - www
```


The fragmentId is the identifier to the html fragment generator script.
It can contain slash for organizational purposes.


Then, the call to the html service is actually a feature provided by the Core module of kamille.
If you look at the **class-modules/Core/doc/systems/ajax-service.md** document, 
you will see how this technique originated.

Basically, the structure looks like this:

```txt
- app
----- service
--------- $ModuleName
------------- $type    // type can be one of html, gscp, json
----------------- $serviceName.php     // here I suggest serviceName=fragment

``` 

So, I recommend this structure:

```txt
- app
----- service
--------- $ModuleName
------------- fragment.php
```

The parameters will be:

- fragment: the fragmentId
- ...all other parameters are passed directly to the fragment generator script

That's it for the convention.




Couple of notes for the implementors
--------------------------
If you are using jquery, you can use $.get to fetch data, and inject it in your page.
The js code inside script tags will be executed (I tested in firefox with jquery 3.2.1).

However, if you wrap your code into a js event like this:

```js
document.addEventListener("DOMContentLoaded", function (event) {
    // not executed, because the event is not fired again when you import the script
});
```

The code inside the function won't be executed since this particular event is not fired
when "loaded/imported".

However, this does the trick:


```js
$(document).ready(function () {
   // this code is executed when imported :) 
});
```

 













